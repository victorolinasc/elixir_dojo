<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>DOJO sobre Elixir</title>
<!-- 2015-03-27 Sex 17:30 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Victor Oliveira Nascimento &lt;victor.nascimento@concretesolutions.com.br&gt;" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />
<style> .title { color: #FFFFFF } blockquote {color: #FFF; background: none repeat scroll 0% 0% #234B5D; padding: 30px; font-style: italic; border-bottom: 1px inset #FFF; padding-bottom: 14px; padding-top: 14px; margin-left: 120px; margin-right: 120px;} </style>
<script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)  })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-61266695-1', 'auto'); ga('send', 'pageview');</script>

<script type="text/javascript" src="http://thomasf.github.io/solarized-css/org-info.min.js">
/**
 *
 * @source: http://thomasf.github.io/solarized-css/org-info.min.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://thomasf.github.io/solarized-css/org-info.min.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://thomasf.github.io/solarized-css/org-info.min.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "3");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "1");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">DOJO sobre Elixir</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Começando</a>
<ul>
<li><a href="#sec-1-1">1.1. Instalando</a></li>
<li><a href="#sec-1-2">1.2. Familiarizando-se com o shell</a></li>
<li><a href="#sec-1-3">1.3. Se virando no shell</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. Autocomplete</a></li>
<li><a href="#sec-1-3-2">1.3.2. Documentação</a></li>
<li><a href="#sec-1-3-3">1.3.3. Histórico de comandos</a></li>
<li><a href="#sec-1-3-4">1.3.4. Outras utilidades</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. Tipos básicos da linguagem</a>
<ul>
<li><a href="#sec-2-1">2.1. Tipos numéricos: integer e float</a></li>
<li><a href="#sec-2-2">2.2. Constantes nomeadas: atom</a></li>
<li><a href="#sec-2-3">2.3. String e lista de caracteres (exemplo e resultado)</a></li>
<li><a href="#sec-2-4">2.4. Tipos de coleção: Listas, tuplas e mapas</a></li>
<li><a href="#sec-2-5">2.5. Só tem isso?</a></li>
<li><a href="#sec-2-6">2.6. Exercícios</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Arquivos de código fonte</a>
<ul>
<li><a href="#sec-3-1">3.1. Primeiro arquivo</a></li>
<li><a href="#sec-3-2">3.2. Exercícios</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Linguagem funcional</a>
<ul>
<li><a href="#sec-4-1">4.1. Pattern Matching</a></li>
<li><a href="#sec-4-2">4.2. Pattern Matching em funções</a></li>
<li><a href="#sec-4-3">4.3. Funções anônimas</a></li>
<li><a href="#sec-4-4">4.4. Recursividade</a></li>
<li><a href="#sec-4-5">4.5. Guards</a></li>
<li><a href="#sec-4-6">4.6. Outros construtos do Elixir</a></li>
<li><a href="#sec-4-7">4.7. Exerícios</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Criando nosso primeiro projeto: MIX</a>
<ul>
<li><a href="#sec-5-1">5.1. MIX: Elixir build tool</a></li>
<li><a href="#sec-5-2">5.2. Primeiro projeto: mix new</a></li>
<li><a href="#sec-5-3">5.3. Arquivo mix.exs</a></li>
<li><a href="#sec-5-4">5.4. Testes e mais testes</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Desafio cliente de linha de comando do Bitbucket</a>
<ul>
<li><a href="#sec-6-1">6.1. Definindo nosso escopo e interface</a></li>
<li><a href="#sec-6-2">6.2. Dependências no MIX</a></li>
<li><a href="#sec-6-3">6.3. Structs</a></li>
<li><a href="#sec-6-4">6.4. Exercícios</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Guia para um DOJO de Elixir.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Começando</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Instalando</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Garanta que já está com o ambiente instalado. Instruções de instalação estão <a href="http://elixir-lang.org/install.html">aqui</a>.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Familiarizando-se com o shell</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Para começar uma sessão do iex (Interactive Elixir Shell), faça o seguinte teste:
</p>

<div class="org-src-container">

<pre class="src src-sh">iex
</pre>
</div>

<p>
Ao término da execução você deverá ver o shell esperando por comandos. Vamos começar experimentando pelo iex e logo na sequência iremos partir para a execução de scripts elixir.
</p>

<p>
Tentem o seguinte código e verifiquem a saída:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #fcaf3e;">name</span> = <span style="color: #e9b96e;">"Victor"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Hello </span><span style="color: #fcaf3e;">#{name}</span><span style="color: #e9b96e;">!"</span>
</pre>
</div>

<pre class="example">
Hello Victor!
</pre>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Se virando no shell</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Dentro de uma sessão de iex temos várias funções já implementadas. Veremos algumas a seguir.
</p>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Autocomplete</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Por exemplo, temos autocomplete dos módulos do Elixir. Digitem "String." (sem as aspas) e apertem o tab.
</p>

<p>
O resultado será algo como:
</p>

<pre class="example">
iex(7)&gt; String.
Chars                 at/2                  capitalize/1          
chunk/2               codepoints/1          contains?/2           
downcase/1            duplicate/2           ends_with?/2          
first/1               graphemes/1           last/1                
length/1              ljust/2               ljust/3               
lstrip/1              lstrip/2              match?/2              
next_codepoint/1      next_grapheme/1       printable?/1          
replace/4             reverse/1             rjust/2               
rjust/3               rstrip/1              rstrip/2              
slice/2               slice/3               split/1               
split/3               split_at/2            starts_with?/2        
strip/1               strip/2               to_atom/1             
to_char_list/1        to_existing_atom/1    to_float/1            
to_integer/1          to_integer/2          upcase/1              
valid?/1              valid_character?/1
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> Documentação</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Existe uma função h que nos mostra a documentação de qualquer função. Experimentem o seguinte no shell: "h Enum.filter_map" (sem as aspas!!!).
</p>

<p>
O resultado será formatado! Algo como:
</p>
<pre class="example">
iex(8)&gt; h Enum.filter_map

                   def filter_map(collection, filter, mapper)                   

Filters the collection and maps its values in one pass.

Examples

┃ iex&gt; Enum.filter_map([1, 2, 3], fn(x) -&gt; rem(x, 2) == 0 end, &amp;(&amp;1 * 2))
┃ [4]
</pre>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> Histórico de comandos</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Ao chamar a função v (apenas digite v e enter), você poderá ver o histórico de sua sessão.
</p>
</div>
</div>

<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4"><span class="section-number-4">1.3.4</span> Outras utilidades</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Existem milhares de outras funcionalidade que serão mais úteis ao decorrer do DOJO.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Tipos básicos da linguagem</h2>
<div class="outline-text-2" id="text-2">
<p>
Elixir e Erlang compartilham suas estruturas de dados primitivas. Vejamos a seguir quais são:
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Tipos numéricos: integer e float</h3>
<div class="outline-text-3" id="text-2-1">
<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">Integers</span>
<span style="color: #fcaf3e;">a</span> = 1
<span style="color: #fcaf3e;">a</span> = 50
<span style="color: #fcaf3e;">a</span> = 100
<span style="color: #73d216;"># </span><span style="color: #73d216;">Na base hexadecimal</span>
<span style="color: #fcaf3e;">a</span> =  0x1F

<span style="color: #73d216;"># </span><span style="color: #73d216;">Floats</span>
1.0 <span style="color: #73d216;"># </span><span style="color: #73d216;">mesmo padr&#227;o que todas as linguagens :D</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Constantes nomeadas: atom</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">atom &#233; uma constante nomeada</span>
<span style="color: #fcaf3e;">a</span> = <span style="color: #87cefa;">:qualquer_valor</span>
<span style="color: #fcaf3e;">b</span> = :<span style="color: #e9b96e;">'qualquer valor com espa&#231;o'</span>
<span style="color: #fcaf3e;">c</span> = :<span style="color: #e9b96e;">'Qualquer valor mai&#250;sculo com espa&#231;o'</span>
<span style="color: #fcaf3e;">d</span> = <span style="color: #e9b2e3;">String</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">os nomes de m&#243;dulos s&#227;o atoms abreviados. Neste caso String &#233; equivalente ao atom :'Elixir.String'. Veremos mais sobre m&#243;dulos mais para frente</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">true e false s&#227;o apenas um a&#231;&#250;car sint&#225;tico para atoms :true e :false</span>
<span style="color: #fcaf3e;">true</span> = <span style="color: #87cefa;">:true</span>
:<span style="color: #fcaf3e;">false</span> = false
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> String e lista de caracteres (exemplo e resultado)</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">Uma string &#233; inicializada com aspas duplas</span>
<span style="color: #fcaf3e;">a</span> = <span style="color: #e9b96e;">"uma string"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">H&#225; tamb&#233;m docstrings (strings que mant&#233;m a formata&#231;&#227;o em m&#250;ltiplas linhas)</span>
<span style="color: #fcaf3e;">b</span> = <span style="color: #e9b96e;">"""</span>
<span style="color: #e9b96e;">Estou testando uma docstring!</span>

<span style="color: #e9b96e;">Pulei linha e ainda estou dentro da docstring</span>
<span style="color: #e9b96e;">"""</span>
<span style="color: #73d216;"># </span><span style="color: #73d216;">Existe um outro tipo que &#233; uma lista de caracteres que inicializado com aspas simples (usado mais em compatibilidade com o Erlang. Por hora &#233; s&#243; importante saber que existe)</span>
<span style="color: #fcaf3e;">c</span> = <span style="color: #e9b96e;">'abc'</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Em Elixir podemos interpolar valores dentro de Strings. Para imprimirmos um tipo que n&#227;o seja uma String podemos usar #{valor}.</span>

<span style="color: #fcaf3e;">d</span> = <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{123456}</span><span style="color: #e9b96e;">"</span>

<span style="color: #e9b2e3;">IO</span>.puts a
<span style="color: #e9b2e3;">IO</span>.puts b
<span style="color: #e9b2e3;">IO</span>.puts c
<span style="color: #e9b2e3;">IO</span>.puts d
</pre>
</div>

<pre class="example">
uma string
Estou testando uma docstring!

Pulei linha e ainda estou dentro da docstring

abc
123456
</pre>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Tipos de coleção: Listas, tuplas e mapas</h3>
<div class="outline-text-3" id="text-2-4">
<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">Uma lista &#233; um conjunto de elementos vari&#225;vel.</span>
<span style="color: #fcaf3e;">a</span> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

<span style="color: #73d216;"># </span><span style="color: #73d216;">H&#225; uma sintaxe (tanto em Elixir e em Erlang) para tratar com listas</span>
<span style="color: #73d216;"># </span><span style="color: #73d216;">Para separarmos o primeiro item da lista do RESTO da lista usamos o | (pipe)</span>

[ primeiro_item | resto_da_lista ] = a

<span style="color: #73d216;"># </span><span style="color: #73d216;">Ops... muito r&#225;pido? O que ser&#225; que aconteceu? N&#227;o se preocupe com o sinal = (igual) estar estranho agora. Veremos isso a seguir.</span>

<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{primeiro_item}</span><span style="color: #e9b96e;">"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect resto_da_lista}</span><span style="color: #e9b96e;">"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Aqui usamos interpola&#231;&#227;o de String como vimos acima</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Em contrapartida, tuplas s&#227;o um conjunto de tamanho fixo e n&#227;o possuem sintaxe especial</span>
<span style="color: #fcaf3e;">b</span> = {<span style="color: #87cefa;">:ok</span>, <span style="color: #e9b96e;">"isto &#233; uma tupla taggeada"</span>}

<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect b}</span><span style="color: #e9b96e;">"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Usamos o inspect apenas ter uma representa&#231;&#227;o em String do tipo. Veremos melhor adiante...</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Mapas possuem uma sintaxe bem particular e muito legal de trabalhar.</span>
<span style="color: #fcaf3e;">c</span> = %{} <span style="color: #73d216;"># </span><span style="color: #73d216;">mapa vazio!</span>
<span style="color: #fcaf3e;">d</span> = %{<span style="color: #e9b96e;">"eu sou uma chave"</span> =&gt; <span style="color: #e9b96e;">"eu sou um valor"</span>}

<span style="color: #73d216;"># </span><span style="color: #73d216;">Para atualizar um mapa podemos usar um atalho de sintaxe</span>
<span style="color: #fcaf3e;">d</span> = %{ d | <span style="color: #e9b96e;">"eu sou uma chave"</span> =&gt; <span style="color: #e9b96e;">"valor atualizado"</span>}

<span style="color: #73d216;"># </span><span style="color: #73d216;">ATEN&#199;&#195;O! Ele s&#243; ir&#225; atualizar uma chave que j&#225; exista! Se tentar: %{ "uma chave inexistente" =&gt; 1} ir&#225; lan&#231;ar uma exce&#231;&#227;o</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Tamb&#233;m temos em Elixir um tipo chamado de Keyword list. &#201; uma lista de tuplas chave e valor.</span>
<span style="color: #fcaf3e;">e</span> = [{<span style="color: #87cefa;">:chave</span>1, <span style="color: #e9b96e;">"teste"</span>}] <span style="color: #73d216;"># </span><span style="color: #73d216;">-&gt; Uma lista com uma tupla de duas posi&#231;&#245;es {chave, valor}.</span>

[{<span style="color: #87cefa;">:chave</span>1, <span style="color: #e9b96e;">"teste"</span>}] = [<span style="color: #87cefa;">chave1:</span> <span style="color: #e9b96e;">"teste"</span>] <span style="color: #73d216;"># </span><span style="color: #73d216;">-&gt; true!</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Isso &#233; m&#227;o na roda para expressar JSON por exemplo. O seguinte exemplo &#233;:</span>
<span style="color: #73d216;"># </span><span style="color: #73d216;">Ex: {"valor": 32, "nome": "Nome completo" } &#233; igual em estrutura a:</span>
<span style="color: #fcaf3e;">f</span> = [<span style="color: #87cefa;">valor:</span> 32, <span style="color: #87cefa;">nome:</span> <span style="color: #e9b96e;">"Nome completo"</span>]

<span style="color: #73d216;"># </span><span style="color: #73d216;">Essa sintaxe encurtada tamb&#233;m existe para mapas:</span>
<span style="color: #fcaf3e;">g</span> = %{<span style="color: #87cefa;">chave:</span> <span style="color: #e9b96e;">"valor"</span>}
<span style="color: #fcaf3e;">g</span> = %{g | <span style="color: #87cefa;">chave:</span> <span style="color: #e9b96e;">"outro valor"</span>}

<span style="color: #73d216;"># </span><span style="color: #73d216;">tanto Keyword lists quanto mapas em que as chaves s&#227;o atoms, podemos acessar os valores atrav&#233;s da sintaxe:</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Chamando valor da lista por um atalho -&gt; </span><span style="color: #fcaf3e;">#{inspect f[:valor]}</span><span style="color: #e9b96e;">"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Chamando valor do mapa por um atalho -&gt; </span><span style="color: #fcaf3e;">#{g[:chave]}</span><span style="color: #e9b96e;">"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Especialmente para mapas com chaves em atoms podemos usar um atalho melhor ainda:</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Chamando valor de um mapa por um atalho melhor ainda -&gt; </span><span style="color: #fcaf3e;">#{g.chave}</span><span style="color: #e9b96e;">"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">O truque est&#225; em um conceito chamado Protocol do Elixir. N&#227;o veremos protocols em detalhes, mas fica a dica!</span>
</pre>
</div>

<pre class="example">
1
[2, 3, 4, 5, 6, 7, 8, 9, 10]
{:ok, "isto é uma tupla taggeada"}
Chamando valor da lista por um atalho -&gt; 32
Chamando valor do mapa por um atalho -&gt; outro valor
Chamando valor de um mapa por um atalho melhor ainda -&gt; outro valor
</pre>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Só tem isso?</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Existem outros tipos na linguagem que falaremos conforme formos avançando. Apenas para os curiosos temos ainda PIDs, structs e outros&#x2026;
</p>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Exercícios</h3>
<div class="outline-text-3" id="text-2-6">
<ol class="org-ol">
<li>Criem um mapa que represente um usuário que possua nome, idade, email, uma lista de endereços.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Arquivos de código fonte</h2>
<div class="outline-text-2" id="text-3">
<p>
Agora chega de só usar o shell e vamos criar arquivos com nossos códigos. Crie uma pasta elixir-dojo onde vamos colocar nosso código.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Primeiro arquivo</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Crie um arquivo module.exs. Façamos um teste. Escrevam no arquivo:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Yo!"</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">projeto para ganhar milh&#245;es</span>
</pre>
</div>

<pre class="example">
Yo!
</pre>

<p>
Para executarmos nosso arquivo podemos simplesmente executar no shell:
</p>
<div class="org-src-container">

<pre class="src src-sh">elixir module.exs
</pre>
</div>

<p>
Isso irá avaliar todo o código que criamos dentro do arquivo. Reparem que não precisamos de classes, módulos, pacotes, namespaces e etc.
</p>

<p>
No entanto, vamos logo logo querer separar nosso código em unidades lógicas para ficar mais fácil reutilizar e referenciar.
</p>

<p>
Para isso usamos módulos. Eles são o equivalente ao escopo de classe em linguagens como Ruby, Java e etc. Nós já referenciamos módulos antes quando queríamos imprimir algo na tela:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #e9b2e3;">IO</span>.puts(<span style="color: #e9b2e3;">String</span>.capitalize(<span style="color: #e9b96e;">"teste"</span>))
</pre>
</div>

<pre class="example">
Teste
</pre>

<p>
Neste exemplo usamos o módulo IO e String da SDK do Elixir. Chamamos funções definidas DENTRO de cada módulo.
</p>

<p>
Antes de começarmos a usar muitas funções, vamos ver como podemos criar uma função. 
</p>

<p>
Apaguem tudo no arquivo module.exs e digitem o seguinte:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">PrimeiroModulo</span> <span style="color: #b4fa70;">do</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">tudo dentro de do ... end estar&#225; DENTRO do m&#243;dulo</span>
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">diga_ola</span> nome <span style="color: #b4fa70;">do</span>
    <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Ol&#225; mundo! Meu nome &#233; </span><span style="color: #fcaf3e;">#{nome}</span><span style="color: #e9b96e;">"</span>
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">Vamos chamar nosso modulo e funcao</span>
PrimeiroModulo.diga_ola <span style="color: #e9b96e;">"Elixir"</span>
</pre>
</div>

<pre class="example">
Olá mundo! Meu nome é Elixir
</pre>

<p>
Usamos a macro "defmodule" para criar um módulo. Não iremos falar de macros agora, mas agora pense nela como uma palavra reservada.
</p>

<p>
Da mesma forma, definimos funções com "defun".
</p>

<blockquote>
<p>
<b>Atenção!</b>
</p>

<p>
Parênteses em Elixir serão QUASE sempre opcionais. Sempre que o compilador conseguir desambiguizar eles serão opcionais. Há casos em que ele ficará na dúvida se a variável é parte de uma função ou é a chamada para outra função. Assim, caso tenham erros, verifiquem se o compilador está conseguindo desambiguizar.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Exercícios</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li>Escreva um módulo que defina uma função cria_usuario que receberá um nome, idade, email e a lista de endereço.
</li>
<li>Escreva outra função que crie um endereço com logradouro, número e cep.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Linguagem funcional</h2>
<div class="outline-text-2" id="text-4">
<p>
Até aqui tudo parece muito com Java, Python e, principalmente Ruby. Mas não esqueçam que estamos falando de uma linguagem funcional.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Pattern Matching</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Vimos anteriormente que o sinal de igual se comporta um tanto quanto estranhamente&#x2026; Vamos recapitular:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">Exemplo de lista</span>
[ primeiro_item | resto_da_lista ] = [1,2,3,4,5]
</pre>
</div>

<p>
Isso chama-se "pattern matching". Ao invés de pensarmos no igual como uma atribuição (a variável passa a representar um valor), tratamos como uma expressão de igualdade.
</p>

<p>
O lado esquerdo do igual precisa ser igual ao lado direito. Assim, vejamos alguns exemplos:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #fcaf3e;">a</span> = 1 <span style="color: #73d216;"># </span><span style="color: #73d216;">a &#233; uma vari&#225;vel sem valor, ent&#227;o o pattern matching atribui 1 ao valor para que a express&#227;o seja verdadeira</span>
[a] = [1] <span style="color: #73d216;"># </span><span style="color: #73d216;">true</span>
<span style="color: #fcaf3e;">b</span> = [a] <span style="color: #73d216;"># </span><span style="color: #73d216;">true. b n&#227;o tinha valor</span>
[c, d, e]  = [ a, <span style="color: #e9b96e;">"testando"</span>, b] <span style="color: #73d216;"># </span><span style="color: #73d216;">true. O padr&#227;o ir&#225; atribuir as vari&#225;veis do lado direito ao lado esquerdo para a express&#227;o ser verdadeira</span>
</pre>
</div>

<p>
Por isso chamamos o sinal de '=' de operador "match". Caso o lado esquerdo não seja igual ao lado direito ele lançará uma exceção.
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Pattern Matching em funções</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Podemos utilizar pattern matching para definir funções em Elixir. Vejam alguns exemplos:
</p>

<div class="org-src-container">

<pre class="src src-elixir">  <span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Teste</span> <span style="color: #b4fa70;">do</span>
    <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">diga_ola</span> <span style="color: #e9b96e;">"Elixir"</span> <span style="color: #b4fa70;">do</span>
      <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Ol&#225; Elixir!"</span>
    <span style="color: #b4fa70;">end</span> 
    <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">diga_ola</span> <span style="color: #e9b96e;">"Mundo"</span> <span style="color: #b4fa70;">do</span>
      <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"N&#227;o..."</span>
    <span style="color: #b4fa70;">end</span>
  <span style="color: #b4fa70;">end</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">A plataforma ir&#225; chamar a primeira defini&#231;&#227;o de diga_ola</span>
  Teste.diga_ola <span style="color: #e9b96e;">"Elixir"</span>
  <span style="color: #73d216;"># </span><span style="color: #73d216;">A plataforma ir&#225; chamar a segunda defini&#231;&#227;o de diga_ola</span>
  Teste.diga_ola <span style="color: #e9b96e;">"Mundo"</span>

  <span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">TesteMaisComplexo</span> <span style="color: #b4fa70;">do</span>
    <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">calcula_area</span> {<span style="color: #87cefa;">:quadrado</span>, {<span style="color: #87cefa;">:lado</span>, lado}} <span style="color: #b4fa70;">do</span>
      lado * lado
    <span style="color: #b4fa70;">end</span>
    <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">calcula_area</span> {<span style="color: #87cefa;">:retangulo</span>, {<span style="color: #87cefa;">:largura</span>, largura}, {<span style="color: #87cefa;">:altura</span>, altura}} <span style="color: #b4fa70;">do</span>
      largura * altura
    <span style="color: #b4fa70;">end</span>
  <span style="color: #b4fa70;">end</span>

<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"-------------"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Quadrado: </span><span style="color: #fcaf3e;">#{inspect TesteMaisComplexo.calcula_area {:quadrado, {:lado, 10}</span><span style="color: #e9b96e;">}}"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Retangulo </span><span style="color: #fcaf3e;">#{inspect TesteMaisComplexo.calcula_area {:retangulo, {:largura, 5}</span><span style="color: #e9b96e;">, {:altura, 10}}}"</span>
</pre>
</div>

<pre class="example">
Olá Elixir!
Não...
-------------
Quadrado: 100
Retangulo 50
</pre>

<p>
Neste exemplo definimos uma função (e não duas!!!) que pode ter duas entradas diferentes: um quadrado ou um retangulo.
</p>

<p>
Quando chamamos a execução o Elixir irá fazer um "pattern matching" para saber qual implementação ele deve chamar.
</p>

<p>
Caso não encontre uma implementação, adivinha&#x2026; exception :D. Assim é possível ter um caso genérico ao definir uma função.
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">PatternMatchingCasoGenerico</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">eh_um_pinguim</span>(<span style="color: #87cefa;">:pinguim</span>), <span style="color: #87cefa;">do:</span> true
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">eh_um_pinguim</span>(<span style="color: #e9b2e3;">_</span>), <span style="color: #87cefa;">do:</span> false 
<span style="color: #b4fa70;">end</span>

<span style="color: #e9b2e3;">IO</span>.puts PatternMatchingCasoGenerico.eh_um_pinguim <span style="color: #87cefa;">:pinguim</span>
<span style="color: #e9b2e3;">IO</span>.puts PatternMatchingCasoGenerico.eh_um_pinguim <span style="color: #87cefa;">:ornitorrinco</span>
</pre>
</div>

<pre class="example">
true
false
</pre>

<p>
Para fazer um "match" genérico utilizamos o underscore '_'. 
</p>

<blockquote>
<p>
<b>Atenção</b>!
</p>

<p>
Usamos uma sintaxe encurtada para definir uma função. Quando o retorno cabe emum linha só, ao invés de escrevermos:
</p>

<p>
def nome() do 
&#x2026;
end
</p>

<p>
Podemos utilizar:
</p>

<p>
def nome(parametros), do: &#x2026;
</p>
</blockquote>

<blockquote>
<p>
<b>Atenção</b>!
</p>

<p>
O uso de parênteses no Elixir será sempre opcional quando a plataforma conseguir detectar que não há ambiguidade.
</p>

<p>
Por exemplo:
</p>

<p>
def eh_um_pinguim :pinguim, do: true
</p>

<p>
Irá lançar uma exceção porque a plataforma não identifica se ", do" é outro parâmetro da função. Por isso utilizamos os parênteses.
</p>
</blockquote>

<p>
Apenas mais um exemplo para mostrar o poder de pattern matching em funções com argumentos keyword.
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">KeyWordMatch</span> <span style="color: #b4fa70;">do</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">busca_usuario</span> <span style="color: #87cefa;">name:</span> name <span style="color: #b4fa70;">do</span>
    <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Buscando usu&#225;rio pelo nome </span><span style="color: #fcaf3e;">#{name}</span><span style="color: #e9b96e;">"</span>
  <span style="color: #b4fa70;">end</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">busca_usuario</span> <span style="color: #87cefa;">email:</span> email <span style="color: #b4fa70;">do</span>
    <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Buscando usu&#225;rio pelo e-mail </span><span style="color: #fcaf3e;">#{email}</span><span style="color: #e9b96e;">"</span>
  <span style="color: #b4fa70;">end</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">busca_usuario</span> <span style="color: #87cefa;">idade:</span> idade <span style="color: #b4fa70;">do</span>
    <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Buscando usu&#225;rio pela idade </span><span style="color: #fcaf3e;">#{inspect idade}</span><span style="color: #e9b96e;">"</span>
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>

KeyWordMatch.busca_usuario <span style="color: #87cefa;">name:</span> <span style="color: #e9b96e;">"Joseph Klimber"</span> 
KeyWordMatch.busca_usuario <span style="color: #87cefa;">email:</span> <span style="color: #e9b96e;">"Joseph.Klimber@pesodepapel.com"</span> 
KeyWordMatch.busca_usuario <span style="color: #87cefa;">idade:</span> 10
</pre>
</div>

<pre class="example">
Buscando usuário pelo nome Joseph Klimber
Buscando usuário pelo e-mail Joseph.Klimber@pesodepapel.com
Buscando usuário pela idade 10
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Funções anônimas</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Elixir não seria uma linguagem funcional se não tivesse "fun"s, ou seja, funções anônimas :D Vejamos alguns exemplos:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">A assintatura de uma fun &#233;:</span>
<span style="color: #73d216;">#</span>
<span style="color: #73d216;"># </span><span style="color: #73d216;">fn parametros -&gt; corpo end</span>
<span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">fn</span> nome -&gt; <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Hello fun </span><span style="color: #fcaf3e;">#{nome}</span><span style="color: #e9b96e;">"</span> <span style="color: #b4fa70;">end</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">fn &#233; uma palavra reservada</span>
<span style="color: #73d216;"># </span><span style="color: #73d216;">parametros pode ser nenhum, um ou muitos:</span>
<span style="color: #fcaf3e;">b</span> = <span style="color: #b4fa70;">fn</span> -&gt; <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Sem par&#226;metros"</span> <span style="color: #b4fa70;">end</span>
<span style="color: #fcaf3e;">c</span> = <span style="color: #b4fa70;">fn</span> param1, param2, param3 -&gt; <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Muitos par&#226;metros </span><span style="color: #fcaf3e;">#{param1}</span><span style="color: #e9b96e;"> - </span><span style="color: #fcaf3e;">#{param2}</span><span style="color: #e9b96e;"> - </span><span style="color: #fcaf3e;">#{param3}</span><span style="color: #e9b96e;">"</span> <span style="color: #b4fa70;">end</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">para chamar uma fun&#231;&#227;o an&#244;nima em Elixir &#233; s&#243; utilizar a sintaxe:</span>
a.(<span style="color: #e9b96e;">"Elixir"</span>)
b.()
c.(<span style="color: #e9b96e;">"1"</span>, <span style="color: #e9b96e;">"2"</span>, <span style="color: #e9b96e;">"3"</span>)
</pre>
</div>

<pre class="example">
Hello fun Elixir
Sem parâmetros
Muitos parâmetros 1 - 2 - 3
</pre>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Recursividade</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Muita gente lembra com horror recursividade da faculdade&#x2026; Provas "maledetas" com perguntas complicadas sobre cálculos recursivos não soa nada bacana&#x2026;
</p>

<p>
No entanto, é uma parte fundamental do Elixir e veremos que não é nenhum bixo de sete cabeças. Prontos para o exemplo clássico?
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Fibonacci</span> <span style="color: #b4fa70;">do</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">fib</span>(1), <span style="color: #87cefa;">do:</span> 1
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">fib</span>(2), <span style="color: #87cefa;">do:</span> 1
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">fib</span>(n) <span style="color: #b4fa70;">when</span> is_integer(n) <span style="color: #b4fa70;">and</span> n &gt; 2 <span style="color: #b4fa70;">do</span>
   fib(n - 1) + fib(n - 2)
  <span style="color: #b4fa70;">end</span> 
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">fib</span>(<span style="color: #e9b2e3;">_</span>) <span style="color: #b4fa70;">do</span>
     <span style="color: #b4fa70;">raise</span> ArgumentError, <span style="color: #87cefa;">message:</span> <span style="color: #e9b96e;">"N&#250;mero inv&#225;lido"</span>
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>

<span style="color: #e9b2e3;">IO</span>.puts Fibonacci.fib(5)
<span style="color: #e9b2e3;">IO</span>.puts Fibonacci.fib(1)
<span style="color: #e9b2e3;">IO</span>.puts Fibonacci.fib(2)
<span style="color: #e9b2e3;">IO</span>.puts Fibonacci.fib(6)
</pre>
</div>

<pre class="example">
5
1
1
8
</pre>

<p>
Vamos por partes:
</p>

<ul class="org-ul">
<li>Usamos a notação "encurtada" para definir nossas cláusulas
</li>
<li>Usamos o que chamamos de guard. Falaremos com mais detalhes a frente
</li>
<li>Usamos o '_' para o caso genérico. Qualquer valor que não seja um número e esteja de 1 para cima.
</li>
<li>Lançamos uma exceção :D. Veremos que isso não é uma boa prática de acordo com o OTP. Em geral os retornos são tuplas do tipo {:ok, valor} ou {:error, "Número inválido}
</li>
<li>Há um truque de sintaxe aqui&#x2026; repare no argumento de raise: módulo e ???? Alguém? &#x2026; É uma Keyword list. Como ela é o último parâmetro, o Elixir não exige os colchetes.
</li>
</ul>

<p>
Mais alguns exemplos de funções recursivas:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">FamosaRecursao</span> <span style="color: #b4fa70;">do</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">fun&#231;&#245;es p&#250;blicas!</span>
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">soma</span>(lista) <span style="color: #b4fa70;">when</span> is_list(lista), <span style="color: #87cefa;">do:</span> soma(lista, 0)

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">map</span>(lista, funcao) <span style="color: #b4fa70;">when</span> is_list(lista) <span style="color: #b4fa70;">and</span> is_function(funcao) <span style="color: #b4fa70;">do</span>
    map(lista, funcao, [])
  <span style="color: #b4fa70;">end</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">fun&#231;&#245;es privadas</span>
  <span style="color: #73d216;"># </span><span style="color: #73d216;">caso b&#225;sico: quando a lista &#233; vazia temos que parar a recurs&#227;o</span>
  <span style="color: #b4fa70;">defp</span> <span style="color: #fce94f;">soma</span>([], acumulador), <span style="color: #87cefa;">do:</span> acumulador
  <span style="color: #73d216;"># </span><span style="color: #73d216;">recurs&#227;o foderosa...</span>
  <span style="color: #b4fa70;">defp</span> <span style="color: #fce94f;">soma</span> [num | lista], acumulador <span style="color: #b4fa70;">do</span>
    soma lista, acumulador + num
  <span style="color: #b4fa70;">end</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">exatamente a mesma coisa...</span>
  <span style="color: #b4fa70;">defp</span> <span style="color: #fce94f;">map</span>([], _funcao, acumulador), <span style="color: #87cefa;">do:</span> acumulador
  <span style="color: #b4fa70;">defp</span> <span style="color: #fce94f;">map</span>([ item | lista], funcao, acumulador) <span style="color: #b4fa70;">do</span>

    <span style="color: #73d216;"># </span><span style="color: #73d216;">usando fun&#231;&#245;es an&#244;nimas como par&#226;metros</span>
    map(lista, funcao, [ funcao.(item) | acumulador ])
  <span style="color: #b4fa70;">end</span>

<span style="color: #b4fa70;">end</span>

<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect FamosaRecursao.soma [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}</span><span style="color: #e9b96e;">"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect FamosaRecursao.soma Enum.to_list(1..100)}</span><span style="color: #e9b96e;">"</span>

<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect FamosaRecursao.map [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], fn numero -&gt; numero + 1 end}</span><span style="color: #e9b96e;">"</span>
<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect FamosaRecursao.map Enum.to_list(1..100), fn numero -&gt; numero + 1 end}</span><span style="color: #e9b96e;">"</span>
</pre>
</div>

<pre class="example">
55
5050
[11, 10, 9, 8, 7, 6, 5, 4, 3, 2]
[101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, ...]
</pre>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Guards</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Vimos alguns exemplos de definições de funções que tinham "guards", mas o que será isso?
</p>

<p>
A filosofia de um sistema tolerante a falhas é: "não escreverás código defensivo". Isso quer dizer: "deixa quebrar logo".
</p>

<p>
Até parece que não há uma preocupação com o fluxo do sistema, mas na verdade isso apenas evidenciará erros nos nossos sistemas antes no ciclo de desenvolvimento.
</p>

<p>
No entanto, podemos indicar melhor qual a intenção da função através de condições claras do que esperamos. Fazemos isso com "guards" que nada mais são do que funções especiais.
</p>

<p>
Normalmente estas funções estão no escopo do Kernel e retornam true ou false. Os que mais utilizaremos são as funções is_*alguma coisa*(parametro)
</p>

<p>
Exemplos:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">GuardTest</span> <span style="color: #b4fa70;">do</span>
<span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">f1</span>(param) <span style="color: #b4fa70;">when</span> is_list(param), <span style="color: #87cefa;">do:</span> <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Sou uma lista"</span>
<span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">f1</span>(param) <span style="color: #b4fa70;">when</span> is_binary(param), <span style="color: #87cefa;">do:</span> <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Sou um bin&#225;rio"</span>
<span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">f1</span>(param) <span style="color: #b4fa70;">when</span> is_map(param), <span style="color: #87cefa;">do:</span> <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Sou um mapa"</span>
<span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">f1</span>(<span style="color: #e9b2e3;">_</span>), <span style="color: #87cefa;">do:</span> <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Sou qualquer outra coisa"</span>
<span style="color: #b4fa70;">end</span>

GuardTest.f1 <span style="color: #e9b96e;">"bin&#225;rio"</span>
GuardTest.f1 %{}
GuardTest.f1 []
GuardTest.f1 <span style="color: #87cefa;">:atom</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Outros construtos do Elixir</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Reparem que até agora sequer mostramos como funciona um "if" na linguagem nem outros controles básicos. Em verdade, é possível fazer qualquer coisa com o que temos na mão até o momento. É sério! Com pattern matching e recursão fica tudo muito mais fácil. Porém criar uma função para usar o pattern matching toda hora não é sempre conveniente. Por isso a linguagem possui outros construtos que também utilizam pattern matching:
</p>

<div class="org-src-container">

<pre class="src src-elixir">  <span style="color: #73d216;"># </span><span style="color: #73d216;">Primeiro e mais poderoso construto &#233; o "case"</span>

  <span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Case</span> <span style="color: #b4fa70;">do</span>
    <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">case_test</span> nome <span style="color: #b4fa70;">do</span>

      <span style="color: #73d216;"># </span><span style="color: #73d216;">passamos qualquer vari&#225;vel para ele "testar" no pattern matching</span>
      <span style="color: #b4fa70;">case</span> nome <span style="color: #b4fa70;">do</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">CASO seja Elixir</span>
  <span style="color: #e9b96e;">"Elixir"</span> -&gt; 
     <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Seja bem vindo!"</span>
  <span style="color: #73d216;"># </span><span style="color: #73d216;">CASO seja Java</span>
  <span style="color: #e9b96e;">"Java"</span> -&gt;
     <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Cuidado com seu estado mut&#225;vel!"</span> 
  <span style="color: #73d216;"># </span><span style="color: #73d216;">CASO seja qualquer outra coisa</span>
  <span style="color: #e9b2e3;">_</span> -&gt;
     <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Qualquer outra coisa"</span>
      <span style="color: #b4fa70;">end</span>
    <span style="color: #b4fa70;">end</span>
  <span style="color: #b4fa70;">end</span>

Case.case_test <span style="color: #e9b96e;">"Elixir"</span>
Case.case_test <span style="color: #e9b96e;">"Java"</span>
Case.case_test <span style="color: #e9b96e;">"Python"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">tamb&#233;m temos if, if/else, unless, unless/else</span>

<span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">if</span> true, <span style="color: #87cefa;">do:</span> 1
<span style="color: #fcaf3e;">b</span> = <span style="color: #b4fa70;">if</span> false <span style="color: #b4fa70;">do</span>
      3
    <span style="color: #b4fa70;">else</span>
      4
    <span style="color: #b4fa70;">end</span>

<span style="color: #fcaf3e;">c</span> = <span style="color: #b4fa70;">unless</span> false, <span style="color: #87cefa;">do:</span> 5
<span style="color: #fcaf3e;">d</span> = <span style="color: #b4fa70;">unless</span> true <span style="color: #b4fa70;">do</span>
      6
    <span style="color: #b4fa70;">else</span>
      7
    <span style="color: #b4fa70;">end</span>

<span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"a: </span><span style="color: #fcaf3e;">#{a}</span><span style="color: #e9b96e;">\nb: </span><span style="color: #fcaf3e;">#{b}</span><span style="color: #e9b96e;">\nc: </span><span style="color: #fcaf3e;">#{c}</span><span style="color: #e9b96e;">\nd: </span><span style="color: #fcaf3e;">#{d}</span><span style="color: #e9b96e;">"</span>
</pre>
</div>

<pre class="example">
Seja bem vindo!
Cuidado com seu estado mutável!
Qualquer outra coisa
a: 1
b: 4
c: 5
d: 7
</pre>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Exerícios</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Criem um módulo que contenha as seguintes funções:
</p>

<ol class="org-ol">
<li>Filter: dada uma lista de elementos retornar apenas aqueles que satisfazem a função de filtro. O resultado da função será sempre true ou false e não precisa se preocupar com guards.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">filter</span> (lista_de_elementos, funcao_de_filtro) <span style="color: #b4fa70;">do</span>
<span style="color: #73d216;">## </span><span style="color: #73d216;">????</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<ol class="org-ol">
<li>Inversão de lista: lembra como o resultado sempre vem invertido da função map? Crie uma função que inverta o resultado.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">inverte</span>(lista), <span style="color: #87cefa;">do:</span> <span style="color: #73d216;">#</span><span style="color: #73d216;">????</span>
</pre>
</div>

<ol class="org-ol">
<li>Fatorial :D Dado um número positivo, calcular N * (N - 1 ) * (N - 2) &#x2026; 1
</li>
</ol>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">fac</span>(numero), <span style="color: #87cefa;">do:</span> <span style="color: #73d216;">#</span><span style="color: #73d216;">????</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Criando nosso primeiro projeto: MIX</h2>
<div class="outline-text-2" id="text-5">
<p>
Até agora estamos executando código em arquivos soltos sem uma estrutura de projeto bem definida. De agora em diante vamos criar projetos completos.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> MIX: Elixir build tool</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Equivalente a Maven, Gradle, NPM e um mix de outras ferramentas de Ruby e Python, MIX representa o sistema de build do Elixir. Vejamos as tasks do mix:
</p>

<div class="org-src-container">

<pre class="src src-elixir">mix                   <span style="color: #73d216;"># </span><span style="color: #73d216;">Run the default task (current: mix run)</span>
mix archive           <span style="color: #73d216;"># </span><span style="color: #73d216;">List all archives</span>
mix archive.build     <span style="color: #73d216;"># </span><span style="color: #73d216;">Archive this project into a .ez file</span>
mix archive.install   <span style="color: #73d216;"># </span><span style="color: #73d216;">Install an archive locally</span>
mix archive.uninstall <span style="color: #73d216;"># </span><span style="color: #73d216;">Uninstall archives</span>
mix clean             <span style="color: #73d216;"># </span><span style="color: #73d216;">Delete generated application files</span>
mix cmd               <span style="color: #73d216;"># </span><span style="color: #73d216;">Executes the given command</span>
mix compile           <span style="color: #73d216;"># </span><span style="color: #73d216;">Compile source files</span>
mix compile.protocols <span style="color: #73d216;"># </span><span style="color: #73d216;">Consolidates all protocols in all paths</span>
mix deps              <span style="color: #73d216;"># </span><span style="color: #73d216;">List dependencies and their status</span>
mix deps.clean        <span style="color: #73d216;"># </span><span style="color: #73d216;">Remove the given dependencies' files</span>
mix deps.compile      <span style="color: #73d216;"># </span><span style="color: #73d216;">Compile dependencies</span>
mix deps.get          <span style="color: #73d216;"># </span><span style="color: #73d216;">Get all out of date dependencies</span>
mix deps.unlock       <span style="color: #73d216;"># </span><span style="color: #73d216;">Unlock the given dependencies</span>
mix deps.update       <span style="color: #73d216;"># </span><span style="color: #73d216;">Update the given dependencies</span>
mix <span style="color: #b4fa70;">do</span>                <span style="color: #73d216;"># </span><span style="color: #73d216;">Executes the tasks separated by comma</span>
mix escript.build     <span style="color: #73d216;"># </span><span style="color: #73d216;">Builds an escript for the project</span>
mix help              <span style="color: #73d216;"># </span><span style="color: #73d216;">Print help information for tasks</span>
mix hex.config        <span style="color: #73d216;"># </span><span style="color: #73d216;">Read or update hex config</span>
mix hex.docs          <span style="color: #73d216;"># </span><span style="color: #73d216;">Publish docs for package</span>
mix hex.info          <span style="color: #73d216;"># </span><span style="color: #73d216;">Print hex information</span>
mix hex.key           <span style="color: #73d216;"># </span><span style="color: #73d216;">Hex API key tasks</span>
mix hex.owner         <span style="color: #73d216;"># </span><span style="color: #73d216;">Hex package ownership tasks</span>
mix hex.publish       <span style="color: #73d216;"># </span><span style="color: #73d216;">Publish a new package version</span>
mix hex.search        <span style="color: #73d216;"># </span><span style="color: #73d216;">Search for package names</span>
mix hex.user          <span style="color: #73d216;"># </span><span style="color: #73d216;">Hex user tasks</span>
mix loadconfig        <span style="color: #73d216;"># </span><span style="color: #73d216;">Loads and persists the given configuration</span>
mix local             <span style="color: #73d216;"># </span><span style="color: #73d216;">List local tasks</span>
mix local.hex         <span style="color: #73d216;"># </span><span style="color: #73d216;">Install hex locally</span>
mix local.rebar       <span style="color: #73d216;"># </span><span style="color: #73d216;">Install rebar locally</span>
mix new               <span style="color: #73d216;"># </span><span style="color: #73d216;">Create a new Elixir project</span>
mix run               <span style="color: #73d216;"># </span><span style="color: #73d216;">Run the given file or expression</span>
mix test              <span style="color: #73d216;"># </span><span style="color: #73d216;">Run a project's tests</span>
iex -S mix            <span style="color: #73d216;"># </span><span style="color: #73d216;">Start IEx and run the default task</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Primeiro projeto: mix new</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Vamos criar um projeto desafio_cs. Primeiro vamos criar o projeto. Utilizemos o mix:
</p>

<div class="org-src-container">

<pre class="src src-sh">mix new desafio_cs
</pre>
</div>

<p>
Os arquivos gerados são:
</p>

<div class="org-src-container">

<pre class="src src-elixir">README.md <span style="color: #73d216;"># </span><span style="color: #73d216;">mix j&#225; cria um README do seu projeto</span>
.gitignore <span style="color: #73d216;"># </span><span style="color: #73d216;">tamb&#233;m j&#225; ganha um .gitignore</span>
mix.exs <span style="color: #73d216;"># </span><span style="color: #73d216;">arquivo principal descritor da nossa aplica&#231;&#227;o</span>
config <span style="color: #73d216;"># </span><span style="color: #73d216;">diret&#243;rio de configura&#231;&#245;es</span>
config/config.exs <span style="color: #73d216;"># </span><span style="color: #73d216;">configs default</span>
lib <span style="color: #73d216;"># </span><span style="color: #73d216;">diret&#243;rio onde ir&#225; nosso c&#243;digo</span>
lib/desafio_cs.ex <span style="color: #73d216;"># </span><span style="color: #73d216;">arquivo principal do nosso projeto (modulo principal)</span>
test <span style="color: #73d216;"># </span><span style="color: #73d216;">diret&#243;rio de testes</span>
test/test_helper.exs <span style="color: #73d216;"># </span><span style="color: #73d216;">arquivo para preparar o framework de test</span>
test/desafio_cs_test.exs <span style="color: #73d216;"># </span><span style="color: #73d216;">nosso primeiro arquivo de testes</span>
</pre>
</div>

<p>
Vemos logo de cara que um projeto em Elixir possui uma estrutura bem definida com tudo o que precisamos. Testes, configurações e nosso próprio código.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Arquivo mix.exs</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Vamos ver o conteúdo padrão do arquivo. 
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">DesafioCs.Mixfile</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #b4fa70;">use</span> <span style="color: #8cc4ff;">Mix.Project</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">project</span> <span style="color: #b4fa70;">do</span>
    [<span style="color: #87cefa;">app:</span> <span style="color: #87cefa;">:desafio_cs</span>,
     <span style="color: #87cefa;">version:</span> <span style="color: #e9b96e;">"0.0.1"</span>,
     <span style="color: #87cefa;">elixir:</span> <span style="color: #e9b96e;">"~&gt; 1.0"</span>,
     <span style="color: #87cefa;">deps:</span> deps]
  <span style="color: #b4fa70;">end</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">Configuration for the OTP application</span>
  <span style="color: #73d216;">#</span>
  <span style="color: #73d216;"># </span><span style="color: #73d216;">Type `mix help compile.app` for more information</span>
  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">application</span> <span style="color: #b4fa70;">do</span>
    [<span style="color: #87cefa;">applications:</span> [<span style="color: #87cefa;">:logger</span>]]
  <span style="color: #b4fa70;">end</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">Dependencies can be Hex packages:</span>
  <span style="color: #73d216;">#</span>
  <span style="color: #73d216;">#   </span><span style="color: #73d216;">{:mydep, "~&gt; 0.3.0"}</span>
  <span style="color: #73d216;">#</span>
  <span style="color: #73d216;"># </span><span style="color: #73d216;">Or git/path repositories:</span>
  <span style="color: #73d216;">#</span>
  <span style="color: #73d216;">#   </span><span style="color: #73d216;">{:mydep, git: "https://github.com/elixir-lang/mydep.git", tag: "0.1.0"}</span>
  <span style="color: #73d216;">#</span>
  <span style="color: #73d216;"># </span><span style="color: #73d216;">Type `mix help deps` for more examples and options</span>
  <span style="color: #b4fa70;">defp</span> <span style="color: #fce94f;">deps</span> <span style="color: #b4fa70;">do</span>
    []
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<p>
Este é um módulo padrão do Elixir. Ele se equipara a um pom.xml ou build.gradle.
</p>

<p>
Talvez o mais diferente para olhos não treinados seja o valor da chave deps na keyword de retorno da função application. Ela nada mais é que a chamada da função deps sem argumentos.
</p>

<p>
Há uma palavra nova para nós que é o "use Mix.Project". Isto é uma forma de importarmos os módulo Mix.Project com um tempero a mais&#x2026;
</p>

<p>
Não vamos tratar disso agora, mas a palavra "use" permite que o módulo referenciado injete funções no nosso módulo. Isso é um tópico avançado que envolve metaprogramação. Veremos isso mais adiante!
</p>

<p>
Os atributos do nosso projeto são pré definidos pela especificação do Mix. Na <a href="http://elixir-lang.org/docs/v1.0/mix/">documentação</a> há todas as possibilidades.
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Testes e mais testes</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Sei que ainda não falamos do que se trata nosso desafio, mas vejamos o que há no arquivo desafio_cs_test.exs
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">DesafioCsTest</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #b4fa70;">use</span> <span style="color: #8cc4ff;">ExUnit.Case</span>

  test <span style="color: #e9b96e;">"the truth"</span> <span style="color: #b4fa70;">do</span>
    assert 1 + 1 == 2
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<p>
Isso é um pouco irritante para um filósofo, mas vemos que há o teste "da verdade". De novo temos a palavra "use"&#x2026; 
</p>

<p>
Parece que esse código não compila né? Não existe a palavra reservada "test". Muito menos a assert. Porém, lembra que do que falamos sobre "use"?
</p>

<p>
Exato. ExUnit.Case injeta algumas funções no nosso módulo. É o caso das duas funções que falamos. A primeira recebe uma string (binary) e um bloco de execução. A segunda verifica se o operador é satisfeito dado o que é passado antes e depois dele.
</p>

<p>
Podemos executar este teste usando o mix. Na raiz do projeto é só digitar mix test. Para quem usa uma IDE ou plugin, verifique a documentação de cada um. Por exemplo, no Emacs o atalho é C-c a t.
</p>

<p>
Se não acontecer nada no reino da Matemática, o teste deve passar.
</p>

<p>
Para criarmos um novo teste basta criar outra chamada para "test". Exemplo:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">DesafioCsTest</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #b4fa70;">use</span> <span style="color: #8cc4ff;">ExUnit.Case</span>

  test <span style="color: #e9b96e;">"the truth"</span> <span style="color: #b4fa70;">do</span>
    assert 1 + 1 == 2
  <span style="color: #b4fa70;">end</span>

  test <span style="color: #e9b96e;">"com string"</span> <span style="color: #b4fa70;">do</span>
    assert <span style="color: #e9b96e;">"minha string bonita"</span> ~= <span style="color: #e9b96e;">"bonita"</span>
  <span style="color: #b4fa70;">end</span>

  test <span style="color: #e9b96e;">"que ir&#225; quebrar tudo"</span> <span style="color: #b4fa70;">do</span>
    assert <span style="color: #e9b96e;">"minha string bonita"</span> ~= <span style="color: #e9b96e;">"sua feia"</span>
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<p>
Neste caso usamos outro operador: =~. Ele verifica se o RHS (right hand side), ou seja, o que há do lado direito dele está contido no lado esquerdo (LHS).
</p>

<p>
No primeiro caso "com string" tudo está ok. O RHS está contido no LHS. Porém no caso abaixo irá falhar. Veja que na mensagem de erro ele usa justamente RHS e LHS. 
</p>
</div>
</div>
</div>


<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Desafio cliente de linha de comando do Bitbucket</h2>
<div class="outline-text-2" id="text-6">
<p>
Pronto! Podemos começar nosso desafio. Apenas para recapitular, nós vimos:
</p>

<ul class="org-ul">
<li>Tipos básicos da linguagem
</li>
<li>Como criar funções em módulos e como chamá-las
</li>
<li>Como definir melhor o contrato das funções com guards
</li>
<li>Aspectos da linguagem funcional como recursão e pattern matching
</li>
<li>Como criar um projeto mix
</li>
<li>Como criar testes para o nosso projeto
</li>
<li>Como executar os testes do projeto
</li>
</ul>

<p>
Agora vamos utlizar tudo isso para consultarmos uma API REST e exibí-la pelo console iex. Prontos?
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Definindo nosso escopo e interface</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Queremos fazer um request para um repositório e listar de forma legível todos os pullrequests associados àquele repositório. Simples não?
</p>

<p>
Primeiro vamos abrir nosso primeiro arquivo ".ex". Ele está dentro da pasta lib e por enquanto contém apenas:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">DesafioCs</span> <span style="color: #b4fa70;">do</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<p>
Nada demais, mas será nele que colocaremos nossas funções.
</p>

<p>
Agora, vamos pensar em como gostaríamos de chamar as funções. Os parâmetros parecem ser:
</p>

<ul class="org-ul">
<li>usuário
</li>
<li>repositório
</li>
</ul>

<p>
De tudo que vimos, podemos pensar em várias formas de definir esta função. Vejamos alguns exemplos:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">DesafioCs</span> <span style="color: #b4fa70;">do</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">pullrequests</span> usuario, repositorio <span style="color: #b4fa70;">do</span>
    <span style="color: #87cefa;">:ok</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">faremos a busca aqui...</span>
  <span style="color: #b4fa70;">end</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">pullrequests2</span> <span style="color: #87cefa;">usuario:</span> usuario, <span style="color: #87cefa;">repositorio:</span> repo <span style="color: #b4fa70;">do</span>
    <span style="color: #87cefa;">:ok</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">talvez um pouco mais idiom&#225;tico... melhor? N&#227;o sei...</span>
  <span style="color: #b4fa70;">end</span>

  <span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">pullrequests3</span> %{<span style="color: #87cefa;">usuario:</span> usuario, <span style="color: #87cefa;">repositorio:</span> repo} <span style="color: #b4fa70;">do</span>
    <span style="color: #87cefa;">:ok</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">mais feio... </span>
  <span style="color: #b4fa70;">end</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<p>
Podemos pensar que a primeira opção e as demais são idênticas. Porém, se quisermos aumentar as opções no futuro teríamos que refatorar todos os lugares que faz esta chamada. Assim, vamos com a segunda opção que é bem simples e mostra a intenção da função.
</p>

<p>
Ok. Mas como eu faço uma requisição para uma API REST?
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Dependências no MIX</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Temos um cliente http puro em Erlang que poderíamos tranquilamente usar para fazer nossa chamada. No entanto, para facilitar nosso lado, utilizaremos uma dependência. 
</p>

<p>
Para isso, basta lembrar que nosso arquivo mix.exs possui uma sessão de dependências. Mas existe um NPM para o Elixir? Um Maven Central? Oh yeah baby&#x2026;
</p>

<p>
Já temos milhares de bibliotecas puras em Elixir no gerenciador de pacotes <a href="http://hex.pm">Hex</a>. Desde banco de dados até calendário japonês.
</p>

<p>
Como encontrar uma lib de http? Basta acessar o portal e digitar http na busca. 
</p>

<p>
Utilizaremos a lib :httpoison. Edite o arquivo mix.exs (de acordo com a documentação da lib):
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">application</span> <span style="color: #b4fa70;">do</span>
  [<span style="color: #87cefa;">applications:</span> [<span style="color: #87cefa;">:logger</span>, <span style="color: #87cefa;">:httpoison</span>]]
<span style="color: #b4fa70;">end</span>

<span style="color: #b4fa70;">defp</span> <span style="color: #fce94f;">deps</span> <span style="color: #b4fa70;">do</span>
  [{<span style="color: #87cefa;">:httpoison</span>, <span style="color: #e9b96e;">"~&gt; 0.6"</span>}]
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<p>
Para poder testar a lib, precisamos de mais alguns comandos do mix.
</p>

<div class="org-src-container">

<pre class="src src-sh">mix deps.get
<span style="color: #73d216;"># </span><span style="color: #73d216;">espera baixar a lib (deve ser ridiculamente pequena)</span>
mix deps.compile
<span style="color: #73d216;"># </span><span style="color: #73d216;">ir&#225; perguntar se deve instalar o rebar. Apenas aceite :D</span>
</pre>
</div>

<p>
Após compilar, vamos iniciar uma sessão iex com a dependência no load path:
</p>

<div class="org-src-container">

<pre class="src src-elixir">iex -S mix
</pre>
</div>

<p>
Agora estamos em um shell iex com nosso projeto no path mais nossas dependências. Este comando não é nada assim tão especial&#x2026; com a flag -S podemos passar qualquer script Elixir. No caso passamos um script mix.exs. Ele sabe colocar as dependências no path e identificar que estamos em um projeto.
</p>

<p>
Agora vamos testar algumas coisas. Digite os seguintes comandos no shell:
</p>
<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #73d216;"># </span><span style="color: #73d216;">Vamos testar o HTTPoison!</span>
HTTPoison.get <span style="color: #e9b96e;">"https://api.bitbucket.org/2.0/repositories/suporte_concrete/desafio-android/pullrequests"</span>
</pre>
</div>

<blockquote>
<p>
<b>Atenção!</b>
</p>

<p>
Reparem que logo após digitar o nome do módulo você ganha autocompletion com TAB :D
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Structs</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Vimos que o resultado da API é um mapa meio estranho. Ao invés de retornar: %{} ele retorna um %HTTPoison.Response{}. Mas o que é isso?
</p>

<p>
Trata-se de mais um tipo do Elixir: um struct. Não precisamos entrar em detalhes agora, mas ele é apenas um mapa especial do Elixir. Pode-se fazer um pattern matching normalmente nele quase como se fosse um mapa. Para criar um struct utilizamos a macro "defstruct" mais uma keyword list com os nomes dos campos mais valores default:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Usuario</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #b4fa70;">defstruct</span> <span style="color: #87cefa;">nome:</span> <span style="color: #e9b96e;">"nome default"</span>
<span style="color: #b4fa70;">end</span>

<span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Test</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #fcaf3e;">user</span> = %Usuario{}
  <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{user.nome}</span><span style="color: #e9b96e;">"</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">mesma sintaxe de mapa</span>
  <span style="color: #fcaf3e;">user</span> = %Usuario{ user | <span style="color: #87cefa;">nome:</span> <span style="color: #e9b96e;">"outro nome"</span> } 

  <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{user.nome}</span><span style="color: #e9b96e;">"</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">no entanto, n&#227;o podemos utilizar fun&#231;&#245;es do m&#243;dulo Map para acrescentar chaves</span>
  <span style="color: #fcaf3e;">nao_eh_um_usuario</span> = <span style="color: #e9b2e3;">Map</span>.put user, <span style="color: #87cefa;">:chave</span>, <span style="color: #e9b96e;">"valor"</span>
  <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"N&#227;o &#233; um usu&#225;rio: </span><span style="color: #fcaf3e;">#{inspect nao_eh_um_usuario}</span><span style="color: #e9b96e;">\nUser: </span><span style="color: #fcaf3e;">#{inspect user}</span><span style="color: #e9b96e;">"</span>

  <span style="color: #fcaf3e;">usuario_mais_uma_vez</span> = <span style="color: #e9b2e3;">Map</span>.delete nao_eh_um_usuario, <span style="color: #87cefa;">:chave</span>
  <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"Usu&#225;rio mais uma vez: </span><span style="color: #fcaf3e;">#{inspect usuario_mais_uma_vez}</span><span style="color: #e9b96e;">"</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<pre class="example">
nome default
outro nome
Não é um usuário: %{__struct__: Usuario, chave: "valor", nome: "outro nome"}
User: %Usuario{nome: "outro nome"}
Usuário mais uma vez: %Usuario{nome: "outro nome"}
</pre>

<blockquote>
<p>
<b>Atenção!</b>
</p>

<p>
Reparem que não é possível chamar o struct logo abaixo da sua definição. Para isso criamos outro módulo para separar os contextos.
</p>
</blockquote>

<p>
É importante reparar que um struct nada mais é um mapa com chaves em atoms e com uma chave específica :__struct__: <span class="underline"><span class="underline">MODULE</span></span> (nome do módulo). Com isso podemos até mesmo criar um struct dinamicamente:
</p>

<div class="org-src-container">

<pre class="src src-elixir"><span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Usuario</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #b4fa70;">defstruct</span> <span style="color: #87cefa;">nome:</span> <span style="color: #e9b96e;">"nome default"</span>
<span style="color: #b4fa70;">end</span>

<span style="color: #b4fa70;">defmodule</span> <span style="color: #8cc4ff;">Test</span> <span style="color: #b4fa70;">do</span>
  <span style="color: #fcaf3e;">user</span> = %Usuario{}
  <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect user}</span><span style="color: #e9b96e;">"</span>

  <span style="color: #73d216;"># </span><span style="color: #73d216;">criando o memso usu&#225;rio com um mapa dinamicamente</span>
  <span style="color: #fcaf3e;">outro_user</span> = %{<span style="color: #87cefa;">__struct__:</span> Usuario, <span style="color: #87cefa;">nome:</span> <span style="color: #e9b96e;">"Outro User"</span>}
  <span style="color: #e9b2e3;">IO</span>.puts <span style="color: #e9b96e;">"</span><span style="color: #fcaf3e;">#{inspect outro_user}</span><span style="color: #e9b96e;">"</span> <span style="color: #73d216;"># </span><span style="color: #73d216;">qual ser&#225; o resultado?</span>
<span style="color: #b4fa70;">end</span>
</pre>
</div>

<pre class="example">
%Usuario{nome: "nome default"}
%Usuario{nome: "Outro User"}
</pre>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Exercícios</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Vamos testar o que aprendemos até aqui:
</p>

<ol class="org-ol">
<li>Adicione a biblioteca poison em sua última versão do Hex.pm. Baixe e compile!
</li>

<li>Veja o retorno desta função da lib Poison:
</li>
</ol>
<div class="org-src-container">

<pre class="src src-elixir">Poison.decode! <span style="color: #e9b96e;">"{ \"json_key\": \"json_value\" }"</span>
</pre>
</div>

<ol class="org-ol">
<li>Faça um teste que chama uma url usando HTTPoison. Por exemplo: 
</li>
</ol>

<p>
<a href="https://api.bitbucket.org/2.0/repositories/suporte_concrete/desafio-android/pullrequests">https://api.bitbucket.org/2.0/repositories/suporte_concrete/desafio-android/pullrequests</a>
</p>

<ol class="org-ol">
<li>Implemente nossa função no módulo principal de forma que:
</li>

<li>Aceite o usuário e o repositório
</li>
<li>Retorne uma lista com mapas no seguinte formato:
</li>
</ol>

<p>
%{ "usuario" =&gt; "XXXXXX", "repositorio" =&gt; "XXXXXXXXXXXXX" }
</p>

<ol class="org-ol">
<li>Crie um teste que verifique que o resultado é uma lista que contém apenas mapas.
</li>

<li>Crie outra função que imprime no console a seguinte saída:
</li>
</ol>

<p>
Repositório #{usuario}/#{repositorio}
</p>

<p>
Pull request: #{author} em #{created_on}
&#x2026;
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Victor Oliveira Nascimento &lt;victor.nascimento@concretesolutions.com.br&gt;</p>
<p class="date">Created: 2015-03-27 Sex 17:30</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
